# 예산

### 문제 설명

S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.

물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.

부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- `d`는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.
- `d`의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
- `budget`은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.

### 입출력 예

| d           | budget | result |
| ----------- | ------ | ------ |
| [1,3,2,5,4] | 9      | 3      |
| [2,2,3,3]   | 10     | 4      |

### 입출력 예 설명

입출력 예 #1

- 각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.

  - 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.
  - 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
  - 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
  - 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.
  - 3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.

입출력 예 #2

- 모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.

### 출처

https://school.programmers.co.kr/learn/courses/30/lessons/12982

---

### 1. 의사코드

1. 최대한 많은 부서를 담을 `count` 변수를 만든다.
2. 누적된 합계를 담을 `sum` 변수를 만든다.
3. `d`를 최대한 많이 담기 위해 작은 수부터 담아야 하기 때문에 오름차순으로 만든다.
4. `d`를 하나씩 돌면서 `sum`에 요소를 더해주는데 만약 그 수가 `budget`을 초과한다면 멈춘다.
5. `d`의 요소를 하나씩 더할 때 마다 count를 1씩 올려준다.

### 2. 코드 연결

1. 최대한 많은 부서를 담을 `count` 변수를 만든다.

```javascript
let count = 0;
```

2. 누적된 합계를 담을 `sum` 변수를 만든다.

```javascript
let sum = 0;
```

3. `d`를 최대한 많이 담기 위해 작은 수부터 담아야 하기 때문에 오름차순으로 만든다.

```javascript
d.sort((a, b) => a - b);
```

4. `d`를 하나씩 돌면서 `sum`에 요소를 더해주는데 만약 그 수가 `budget`을 초과한다면 멈춘다.

```javascript
for (let i = 0; i < d.length; i++) {
    if (sum + d[i] > budget) break;
    sum += d[i];
```

5. `d`의 요소를 하나씩 더할 때 마다 count를 1씩 올려준다.

```javascript
count++;
```

### 3. 완성 코드

```javascript
function solution(d, budget) {
  let count = 0;
  let sum = 0;
  d.sort((a, b) => a - b);

  for (let i = 0; i < d.length; i++) {
    if (sum + d[i] > budget) break;
    sum += d[i];
    count++;
  }
  return count;
}
```

💡 break를 통한 for문 멈추기
💡 `if (sum + d[i] > budget)`은 if문의 조건일 뿐 실제 더해지지 않고 앞으로를 예상한다.

💡 다른 사람 풀이 참고

```javascript
function solution(d, budget) {
  return d
    .sort((a, b) => a - b)
    .reduce((count, price) => {
      return count + ((budget -= price) >= 0);
    }, 0);
}
```

1. `budget -= price` : 여기서는 현재의 예산 budget에서 현재 순회 중인 아이템의 가격 price를 빼고, 그 결과를 budget에 다시 저장합니다. 이 연산은 예산을 아이템 가격만큼 감소시킵니다.

2. `(budget -= price) >= 0` : 예산에서 가격을 뺀 후의 결과가 0 이상인지를 검사합니다. 이는 예산이 아직 양수이거나 0인 경우, 즉 아이템을 구매할 수 있는 충분한 예산이 남아 있는지를 확인하는 조건입니다.

3. `((budget -= price) >= 0)` : 이 조건문은 참(true)이면 1을, 거짓(false)이면 0을 반환합니다. JavaScript에서 불리언 값을 숫자로 자동 변환할 때, true는 1로, false는 0으로 변환됩니다.

4. `count + ((budget -= price) >= 0)` : 마지막으로, 현재까지 구매한 아이템의 수인 count에 위의 조건문 결과(1 또는 0)를 더합니다. 이렇게 함으로써, 아이템을 구매할 수 있으면 count가 1 증가하고, 구매할 수 없으면 count는 그대로 유지됩니다.

=> ()안에 비교연산자가 들어가면 조건문으로 인식하고 0또는 1의 결과를 갖을 수 있다.
