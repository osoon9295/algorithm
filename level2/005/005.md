# 이진 변환 반복하기

🗓️ 날짜: 2025.08.12
💡 유형: 문자열, 반복문, 진법 변환

---

### 문제 설명

0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.

    1. x의 모든 0을 제거합니다.
    2. x의 길이를 c라고 하면, x를 "c를 2진법으로 표현한 문자열"로 바꿉니다.

예를 들어, `x = "0111010"`이라면, x에 이진 변환을 가하면 `x = "0111010" -> "1111" -> "100"` 이 됩니다.

0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 "1"이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- s의 길이는 1 이상 150,000 이하입니다.
- s에는 '1'이 최소 하나 이상 포함되어 있습니다.

### 입출력 예

| s              | result |
| -------------- | ------ |
| "110010101001" | [3,8]  |
| "01110"        | [3,3]  |
| "1111111"      | [4,1]  |

### 입출력 예 설명

입출력 예 #1

- "110010101001"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.
  |회차| 이진 변환 이전| 제거할 0의 개수| 0 제거 후 길이 |이진 변환 결과|
  |--|--|--|--|--|
  |1 |"110010101001"| 6 |6 |"110"|
  |2| "110"| 1 |2 |"10"|
  |3| "10"| 1 |1| "1"|

- 3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, [3,8]을 return 해야 합니다.

입출력 예 #2

- "01110"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.
  |회차|이진 변환 이전 |제거할 0의 개수| 0 제거 후 길이 |이진 변환 결과|
  |--|--|--|--|--|
  |1| "01110"| 2 |3| "11"|
  |2| "11"| 0 |2 |"10"|
  |3| "10"| 1 |1 |"1"|

- 3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, [3,3]을 return 해야 합니다.

입출력 예 #3

- "1111111"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.

| 회차 | 이진 변환 이전 | 제거할 0의 개수 | 0 제거 후 길이 | 이진 변환 결과 |
| ---- | -------------- | --------------- | -------------- | -------------- |
| 1    | "1111111"      | 0               | 7              | "111"          |
| 2    | "111"          | 0               | 3              | "11"           |
| 3    | "11"           | 0               | 2              | "10"           |
| 4    | "10"           | 1               | 1              | "1"            |

- 4번의 이진 변환을 하는 동안 1개의 0을 제거했으므로, [4,1]을 return 해야 합니다.

### 출처

https://school.programmers.co.kr/learn/courses/30/lessons/70129?language=javascript

---

## 코드리뷰

#### 나의 코드

```javascript
function solution(s) {
  let answer = [0, 0];

  do {
    s = s.split("").filter((v) => {
      if (v === "0") ++answer[1];
      return v === "1";
    });
    s = s.length.toString(2);
    ++answer[0];
  } while (s.length !== 1);

  return answer;
}
```

#### 내 코드 풀이

🤔 접근 방법 :

- for문은 정적인 조건까지만 반복이 가능해서 동적인 조건까지 반복하기 위해 while을 사용
- 0만큼 answer[1]을 증가시키고 0을 제거
- 0을 제거한 s를 2진법으로 변경
- 이 과정을 반복하고 할때하마다 answer[0] 증가

🤦‍♀️ 틀린 이유/ 막힌 이유 :

- 2진법으로 변경하는 매서드를 몰랐다. (`toString()`)
- while을 거의 처음 사용하는 듯
- s변수를 이용해도 된다는 점을 몰랐음

#### 다른 사람 풀이에서 배울 점

👍 참고할 만한 코드

```javascript
function solution(s) {
  let transformCount = 0;
  let zeroCount = 0;

  while (s !== "1") {
    // 0 개수 세기
    zeroCount += s.split("0").length - 1;
    // 0 제거
    s = s.replace(/0/g, "");
    // 길이 → 2진수
    s = s.length.toString(2);
    // 변환 횟수 증가
    transformCount++;
  }

  return [transformCount, zeroCount];
}
```

- do...while은 s가 "1"이면 오답을 출력
- 종료 조건은 s !=="1"이 더 안전
- 필터 안에서 카운트 증가는 가독성과 유지보수에 안좋음
  - split으로 0의 개수를 구하거나
  - 0을 제거한 후 처음과 비교하여 0의 개수를 알아내는 방법등 사용
- 0을 제거하는 정규식 추천

#### 다시 풀 때 포인트

- filter 없이 0의 개수 구하고 0 제거하기
- 배열화 없이 구하기
- do while 대신 while 사용하기
- toString() 사용
